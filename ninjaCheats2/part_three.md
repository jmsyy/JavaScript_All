## JavaScript(《忍者秘籍2》) md(ninjaCheats2)

### Part Three 对象

### 3.1 面向对象与原型

深入对象原型与新特性
- JavaScript对象是属性名与属性值的集合。
- JavaScript使用原型。
- 每个对象上都具有原型的引用，搜索指定的属性时，如果对象本身不存在该属性，则可以代理到原型上进行搜索。对象的原型也可以具有原型，以此类推，形成原型链。
- 可以通过Object.setPrototypeOf方法定义对象的原型。
- 原型与构造函数密切相关。每个函数都具有原型属性，该函数创建的对象的原型，就是函数本身。
- 函数原型对象具有constructor属性，该属性指向函数本身。该函数创建的全部对象均访问该属性，constructor属性还可用于判断对象是否是由指定的函数创建的。
- 在JavaScript中，几乎所有的内容在运行时都会发生变化，包括对象的原型和函数的原型。
- 如果我们希望Ninja构造函数创建的实例都可以“继承”（更准确地说，可以访问）Person构造函数的属性，那么，将Ninja构造函数的原型设置为Person类的实例。
- 在JavaScript中，原型具有属性（如configurable、enumerable、writable）。这些属性可通过内置的Object.defineProperty方法进行定义。
- JavaScript ES6引入关键字class，使得我们可以更方便地实现模拟类。在底层仍然是使用原型实现的。
- 使用extends可以更优雅地实现继承。

### 3.2 控制对象的访问

我们可以使用getter、setter和代理监控对象。
- 通过使用访问器方法（getter和setter），我们可以对对象属性的访问进行控制。
- 可以通过内置的Object.defineProperty方法定义访问属性，或在对象字面量中使用get和set语法或ES6的class。
- 当读取对象属性时会隐式调用get方法，当写入对象属性时隐式调用set方法。
- 使用getter方法可以定义计算属性，在每次读取对象属性时计算属性值；同理，setter方法可用于实现数据验证与日志记录。
- 代理是JavaScript ES6中引入的，可用于控制对象。
- 代理可以定制对象交互时行为（例如，当读取属性或调用方法时）。
- 所有的交互行为都必须通过代理，指定的行为发生时会调用代理方法。
- 使用代理可以优雅地实现以下内容。
- 日志记录。
- 性能测量。
- 数据校验。
- 自动填充对象属性（以此避免讨厌的null异常）。
- 数组负索引。
- 代理效率不高，所以在需要执行多次的代码中需要谨慎使用。建议进行性能测试。

### 3.3 处理集合

数组是特殊的对象，具有length属性，原型是Array.prototype。
- 可以使用数组字面量([])或Array构造函数创建数组。
- 通过使用数组对象的方法可以修改数组的内容。
- 使用push与pop方法从数组结束位置添加或删除元素。
- 使用shift与unshift方法从数组起始位置添加或删除元素。
- splice方法可以从任意位置添加或删除元素。
- 数组可以访问很多有用的方法。
- map方法可对数组成员调用回调函数，并使用调用结果创建新数组。
- every与some方法检测全部或部分元素是否匹配某些条件。
- find与filter方法查找满足某些条件的元素。
- sort方法对数组排序。
- reduce方法将数组成员合计为一个值。
- 可以在自定义对象上，显式定义对象方法，使用call或apply方法对数组的方法进行复用。
- Map和字典是包含key与value映射关系的对象。
- JavaScript中的对象是糟糕的map，只能使用字符串类型作为key，并且存在访问原型属性的风险。因此，使用内置的Map集合。
- 可以使用for...of循环遍历Map集合。
- Set成员的值都是唯一的。


### 3.4 正则表达式

正则表达式是一个强大的工具，贯穿于现代JavaScript开发中，几乎可用于任意类型的匹配，主要取决于如何在各方面使用正则表达式。本章所介绍的概念能够很好地让你理解高级正则表达式，受益于正则表达式，可以很自信地面对任何具有挑战性的代码。
- 创建正则表达式可以使用正则表达式字面量(/test/)或正则构造函数RegExp(new RegExp("test"))。对于在开发环境明确的推荐使用正则字面量，在运行时则推荐使用构造函数。
- 每个正则都可以使用5个标识符：i——大小写敏感，g——全局匹配，m——支持多行匹配，y——支持粘连匹配，u——支持Unicode转义。在正则后面添加标志位如/test/ig，或作为构造函数的第2个参数传入，如new RegExp("test", "i")。
- 使用section指定一组待匹配的字符。
- 使用^表示匹配字符串的起始位置，$表示字符串的结束位置。
- 使用？表示可选项，+ 表示必须出现1次或多次，* 表示可以出现0次、1次或多次。
- 使用．匹配任何字符。
- 使用反斜线(\) 转义特殊字符(如． [ $ ^)。
- 使用圆括号()对多个术语分组，使用竖线|表示或。
- 通过反斜线+数字如(\1, \2, _等)，可以对匹配的字符串进行反向引用。
- 每个字符串可以使用match函数，match函数的传入参数是正则表达式，返回值是匹配到的全部字符串以及全部捕获。使用replace函数，可以对固定字符串进行替换

### 3.5 代码模块化

小的、组织良好的代码远比庞大的代码更容易理解和维护。优化程序结构和组织方式的一种方式是将代码拆分成小的、耦合相对松散的片段或模块。
- 模块是比对象或函数稍大的、用于组织代码的单元，通过模块可以将程序进行分类。
- 通常来说，模块可以降低理解成本，模块易于维护，并可以提高代码的可重用性。
- 在JavaScript ES6之前，没有内置的模块，开发者们不得不创造性地发挥JavaScript语言现有的特性实现模块化。最流行的方式之一是通过立即执行函数的闭包实现模块。
- 使用立即执行函数创建定义模块变量的闭包，从外部作用域无法访问这些变量。
- 使用闭包可以使模块变量保持活跃。
- 最流行的是模块模式，通常采用立即执行函数，并返回一个新对象作为模块的公共接口。
- 除了模块模式，还有两个流行的模块标准：AMD，可以在浏览器端使用；CommonJS，在JavaScript服务端更流行。AMD可以自动解决依赖，异步加载模块，避免阻塞。CommonJS语法简单，可以同步加载模块（因此在服务端更流行），通过npm（node包管理）可以获取大量模块。
- ES6结合了AMD和CommonJS的特点。ES6模块受CommonJS影响，语法简单，并提供了与AMD类似的异步模块加载机制。
- ES6模块基于文件，一个文件是一个模块。
- 通过关键字export导出标识符，在其他模块中可引用这些标识符。
- 在其他模块中通过关键字import导入标识符。
- 模块可以使用默认导出，通过一个export导出整个模块。
- export与import都可以通过关键字as使用别名。

