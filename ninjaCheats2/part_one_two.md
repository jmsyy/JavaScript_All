## JavaScript(《忍者秘籍2》) md(ninjaCheats2)

## Part One JavaScript现状与页面周期

### 1.1 无处不在的JavaScript

### 1.2 运行时页面构建过程

客户端web应用的执行分为两个阶段
- 页面构建代码是用于创建DOM的，而全局JavaScript代码是遇到script节点时执行的。在这个执行过程中，JavaScript代码能够以任意程度改变当前的DOM，还能够注册事件处理器——事件处理器是一种函数，当某个特定事件（例如，一次鼠标单击或键盘按压）发生后会被执行。注册事件处理器很容易：使用内置的addEventListener方法。
- 事件处理——在同一时刻，只能处理多个不同事件中的一个，处理顺序是事件生成的顺序。事件处理阶段大量依赖事件队列，所有的事件都以其出现的顺序存储在事件队列中。事件循环会检查实践队列的队头，如果检测到了一个事件，那么相应的事件处理器就会被调用。

## Part Two 函数

### 2.1 定义与参数 理解JS中函数的重要性 理解函数式编程

把JavaScript看作函数式语言你就能书写复杂代码。
- 作为第一类对象，函数和JavaScript中其他对象一样。类似于其他对象类型，函数具有以下功能。
 通过字面量创建。
 赋值给变量或属性。
 作为函数参数传递。
 作为函数的结果返回。
 赋值给属性和方法。
- 回调函数是被代码随后“回来调用”的函数，它是一种很常用的函数，特别是在事件处理场景下。
- 函数具有属性，而且这些属性能够被存储任何信息，我们可以利用这个特性来做很多事情；例如：
 可以在函数属性中存储另一个函数用于之后的引用和调用。
 可以用函数属性创建一个缓存（记忆），用于减少不必要的计算。
- 有很多不同类型的函数：函数声明、函数表达式、箭头函数以及函数生成器等。
- 函数声明和函数表达式是两种最主要的函数类型。函数声明必须具有函数名，在代码中它也必须作为一个独立的语句存在。函数表达式可以不必有函数名，但此时它就必须作为其他语句的一部分。
- 箭头函数是JavaScript的一个新增特性，这个特性让我们可以使用更简洁的方式来定义函数。
- 形参是函数定义时列出的变量，而实参是函数调用时传递给函数的值。
- 函数的形参列表和实参列表长度可以不同。
 未赋值的形参求值得到undefined。
 传入的额外实参不会被赋给任何一个命名形参。
- 剩余参数和默认参数是JavaScript的新特性。
 剩余参数——不与任何形参名相匹配的额外实参可以通过剩余参数来引用。
 默认参数——函数调用时，若没传入参数，默认参数可以给函数提供缺省的参数值。

 ### 2.2 函数的调用 理解函数调用的上下文

当调用函数时，除了传入在函数定义中显式声明的参数之外，同时还传入两个隐式参数：arguments与this。
- arguments参数是传入函数的所有参数的集合。具有length属性，表示传入参数的个数，通过arguments参数还可获取那些与函数形参不匹配的参数。在非严格模式下，arguments对象是函数参数的别名，修改arguments对象会修改函数实参，可以通过严格模式避免修改函数实参。
- this表示函数上下文，即与函数调用相关联的对象。函数的定义方式和调用方式决定了this的取值。
- 函数的调用方式有4种。
- 作为函数调用：skulk()。
- 作为方法调用：ninja.skulk()。
- 作为构造函数调用：new Ninja()。
- 通过apply与call方法调用：skulk.apply(ninja)或skulk.call(ninja)。
- 函数的调用方式影响this的取值。
- 如果作为函数调用，在非严格模式下，this指向全局window对象；在严格模式下，this指向undefined。
- 作为方法调用，this通常指向调用的对。
- 作为构造函数调用，this指向新创建的对象。
- 通过call或apply调用，this指向call或apply的第一个参数。
- 箭头函数没有单独的this值，this在箭头函数创建时确定。
- 所有函数均可使用bind方法，创建新函数，并绑定到bind方法传入的参数上。被绑定的函数与原始函数具有一致的行为

### 2.3 闭包与作用域 理解闭包与作用域的形成 

通过闭包可以访问创建闭包时所处环境中的全部变量。闭包为函数创建时所处的作用域中的函数和变量，创建“安全气泡”。通过这种的方式，即使创建函数时所处的作用域已经消失，但是函数仍然能够获得执行时所需的全部内容。
- 我们可以使用闭包的这些高级功能：
- 通过构造函数内的变量以及构造方法来模拟对象的私有属性。
- 处理回调函数，简化代码。
- JavaScript引擎通过执行上下文栈（调用栈）跟踪函数的执行。每次调用函数时，都会创建新的函数执行上下文，并推入调用栈顶端。当函数执行完成后，对应的执行上下文将从调用栈中推出。
- JavaScript引擎通过词法环境跟踪标识符（俗称作用域）。
- 在JavaScript中，我们可以定义全局级别、函数级别甚至块级别的变量。
- 可以使用关键字var、let与const定义变量：
- 关键字var定义距离最近的函数级变量或全局变量。
- 关键字let与const定义距离最近级别的变量，包括块级变量。块级变量在ES6之前版本的JavaScript中是无法实现的。此外，通过关键字const允许定义只能赋值一次的变量。
- 闭包是JavaScript作用域规则的副作用。当函数创建时所在的作用域消失后，仍然能够调用函数。

### 2.4 生成器与promise ES6新特性 书写优雅的异步代码

生成器是一种不会在同时输出所有值序列的函数，而是基于每次的请求生成值。
- 不同于标准函数，生成器可以挂起和回复它们的执行状态。当生成器生成了一个值后，它将会在不阻塞主线程的基础上挂起执行，随后静静地等待下次请求。
- 生成器通过在function后面加一个星号（*）来定义。在生成器函数体内，我们可以使用新的关键字yield来生成一个值并挂起生成器的执行。如果我们想让渡到另一个生成器中，可以使用yield操作符。
- 在我们控制生成器的执行过程中，通过使用迭代器的next方法调用一个生成器，它能够创建一个迭代器对象。除此之外，我们还能够通过next函数向生成器中传入值。
- promise是计算结果值的一个占位符，它是对我们最终会得到异步计算结果的一个保证。promise既可以成功也可以失败，一旦设定好了，就不能够有更多改变。
- promise显著地简化了我们处理异步代码的过程。通过使用then方法来生成promise链，我们就能轻易地处理异步时序依赖。并行执行多个异步任务也同样简单：仅使用Promise.all方法即可。
- 通过将生成器和promise相结合我们能够使用同步代码来简化异步任务。











